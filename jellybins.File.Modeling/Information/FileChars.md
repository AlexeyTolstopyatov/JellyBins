# File Characteristics

Заполняет поля первой таблице на странице Общего отчета.

При создании отчета о двоичном файле, обязательно создается страница
общих свойств, где после имени и пути файла, есть таблица
с описанием требований
Выглядит она как-то так.
```
+---------------------------------------+
| Требования         Ваше устройство    | 
| IBM OS/2           Microsoft Windows  | 
| 2.0                6.1                | 
| Intel x86          Intel x86-64       | 
+---------------------------------------+ 
|                                       | 
| Заполняется        Заполняется        | 
| Analyser.Get()     Analyser.Set()     |
+                                       +
| (Описание) .........| {Не совместимо} <== ??
+---------------------------------------+
```

# Что же такое "??"

Тот самый вопрос в таблице это флаг который появляется
путем сравнения характеристик

# Сравнение Версий

Если сравниваются два файла, параметры которых
можно считать совместимыми (ОС = ОС) и (ЦП = ЦП),
Необходимо узнать: Кто из них старше?
Если требуемая ОС указывается как Windows 10, 
а запускаете вы этот файл из Windows XP (NT 5.2)
Вряд-ли он будет работать!

Для указания максимальных значений версии (основная.дополнительная) используют поля
```C++
unsigned short MajorOsVersion;
unsigned short MinorOsVersion;
```
Для указания минимальных значений версии используют поля
```C++
unsigned short MajorSubsystemVersion;
unsigned short MinorSubsystemVersion;
```
Получается, что Если у файла ```MajorSubsystemVersion``` > Требуемая ```MajorOsVersion```
Существует угроза несовместимости.

# Сравнение архитектур
Субъективно, но я считаю, что флагом несовместимости сразу можно называть
порядок заполнения сегментов.
Мало кто вообще подозревает, что x64 и x86-64 это не одно и то же, из-за
предпочтений Intel - называть одно и то же 10000 разных наименований.
Intel x86-64 это надстройка над Intel x86
Всем она известна как ```AMD-64```, a x64 - Это еще одно из названий архитектуры
процессора Intel Itanium
### Разница
Назад к нашим порядковым баранам: 
1) Внутри Intel x86 порядок заполнения сегментов
называется "От младшего к старшему"
выглядит вот так:
```asm
0x0004 -> 0x0034 -> 0x0234 -> 0x1234
```
Вполне себе можно сказать, что для AMD64 правило такое же.
2) Внутри Intel Itanium (если я помню, зависит от модели) 
Порядок заполнения байт меняется от "x86 момент" до "От старшего к младшему"
То есть вот так:
```asm
0x1000 -> 0x1200 -> 0x1230 -> 0x1234
```

Результат в двух примерах один и тот же, НО младший разряд в одном случае 1 в другом 4
(Если я правильно понимаю документации от Intel)

Порядок заполнения байт определенно сказывается на алгоритме ServiceHost и других частей Windows
Выполняют задачу свою два экземпляра (для IA32 и для IA64) одинаково, но внутри все крутится (от ОЗУ до КЕШа)
все по разному.
Поэтому Windows 10 для x86 != Windows 10 для других архитектур

### Стой, Я недоговорила!
Разрядность важный компонент в сравнении. Почему?
Все очень просто.
1) Внутри Windows собранной для AMD64 даже в папке ```.../System32``` на удивление компоненты 64-разрядные!
2) Чтобы жить 32-разрядным приложениям существует целый клон раздела ```System32``` и целая подсистема:
"Windows On Windows" (и каталог "SysWOW64"). Внутри которого работают уже 32-разрядные приложения
3) Если работать из-под 32 разрядной среды, спрашивать 64-разрядный файл, он НЕбудет работать, 
потому что слоя совместимости из 32 разрядных регистров в 64 разрядные НЕТ.
Это еще можно объяснить с аппаратной стороны:
Windows XP (32 разрядное издание) можно поставить на процессор
Intel с архитектурой (например) ```i386```.
В инструкциях ```i386``` только-только появляется виртуальная адресация (если я правильно помню)
и никаких 64 разрядных регистров там нет. (нет ```RAX```, ```RBX``` и других залежей),
Поэтому приложения, которые используют эти залежи вообще не захотят жить там где их нет.

### Архитектура
Чтож такое архитектура вообще?
Традиционно это только набор команд для процессора.
Но и он у каждого процессора разный.
Поэтому приходится обеспечивать слой совместимости (и другие меры)
Сразу можно сказать, что наборы команд для ARM64 != AMD64. Потому что
ARM это архитектура основанная на RISC, а Intel x86 и ее дополнения
используют комплексные инструкции CISC (еще и с разными названинями! да чтож такое!).

